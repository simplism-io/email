"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MailListener = void 0;
var Imap = require("imap");
var EventEmitter = require("events").EventEmitter;
var simpleParser = require("mailparser").simpleParser;
var fs = require("fs");
var async = require("async");
class MailListener extends EventEmitter {
    constructor(options) {
        super();
        this.forceStop = false;
        this.retry = 0;
        (this.maxRetry = 5),
            (this.retryDelay = 1000),
            (this.markSeen = !!options.markSeen);
        this.mailbox = options.mailbox || "INBOX";
        this.mailName = options.username;
        if ("string" === typeof options.searchFilter) {
            this.searchFilter = [options.searchFilter];
        }
        else {
            this.searchFilter = options.searchFilter || ["UNSEEN"];
        }
        if (options.attachments && options.attachmentOptions === undefined) {
            throw new Error("Missing attachmentOptions inside options when attachments = true");
        }
        this.fetchUnreadOnStart = !!options.fetchUnreadOnStart;
        this.mailParserOptions = options.mailParserOptions || {};
        if (options.attachments &&
            options.attachmentOptions &&
            options.attachmentOptions.stream) {
            this.mailParserOptions.streamAttachments = true;
        }
        this.attachmentOptions = options.attachmentOptions || {};
        this.attachments = options.attachments || false;
        this.attachmentOptions.directory = this.attachmentOptions.directory
            ? this.attachmentOptions.directory
            : "";
        this.imap = new Imap({
            xoauth2: options.xoauth2,
            user: options.username,
            password: options.password,
            host: options.host,
            port: options.port,
            tls: options.tls,
            tlsOptions: options.tlsOptions || {},
            connTimeout: options.connTimeout || 10000,
            authTimeout: options.authTimeout || 5000,
            debug: console.log(),
            maxRetry: 5,
            keepalive: true,
            retryDelay: 1000,
        });
        this.imap.once("ready", this.imapReady.bind(this));
        this.imap.once("close", this.imapClose.bind(this));
        this.imap.on("error", this.imapError.bind(this));
    }
    start() {
        console.log("Detaching existing listener");
        this.imap.removeAllListeners("update");
        this.imap.removeAllListeners("mail");
        console.log("Calling imap connect");
        this.imap.connect();
    }
    stop() {
        this.forceStop = true;
        this.imap.end();
    }
    imapReady() {
        this.imap.openBox(this.mailbox, false, (error, mailbox) => {
            if (error) {
                console.log("Error", error);
                this.emit("error", error);
            }
            else {
                let self = this;
                console.log(`Mailbox '${self.mailName}' connected`);
                this.emit("Mailbox:connected");
                this.emit("mailbox", mailbox);
                if (this.fetchUnreadOnStart) {
                    this.parseUnread.call(this);
                }
                let listener = this.imapMail.bind(this);
                this.imap.on("mail", listener);
                this.imap.on("update", listener);
            }
        });
    }
    imapClose() {
        if (!this.forceStop && this.retry < this.maxRetry) {
            setTimeout(() => {
                console.log("Trying to establish imap connection again...");
                this.start();
            }, this.retryDelay);
            return this.retry++;
        }
        this.emit("server:disconnected");
        console.log("disconnected");
        this.forceStop = false;
        this.retry = 0;
    }
    imapError(error) {
        console.log(error);
        this.emit("error", error);
    }
    imapMail() {
        this.parseUnread.call(this);
    }
    parseUnread() {
        let self = this;
        self.imap.search(self.searchFilter, (error, results) => {
            try {
                if (error) {
                    self.emit("error search", error);
                }
                else if (results.length > 0) {
                    async.each(results, (result, callback) => {
                        console.log(`New mail processing from inbox '${self.mailName}'`);
                        let f = self.imap.fetch(result, {
                            bodies: "",
                            markSeen: true,
                        });
                        f.on("message", (msg, seqno) => {
                            msg.on("body", (stream, info) => __awaiter(this, void 0, void 0, function* () {
                                let parsed = yield simpleParser(stream);
                                self.emit("mail", parsed, seqno);
                                self.emit("headers", parsed.headers, seqno);
                                self.emit("body", {
                                    html: parsed.html,
                                    text: parsed.text,
                                    textAsHtml: parsed.textAsHtml,
                                }, seqno);
                                let attachments = parsed.attachments;
                                if (attachments.length > 0) {
                                    for (let att of attachments) {
                                        if (self.attachments &&
                                            self.attachmentOptions.saveAttachments) {
                                            fs.mkdir(`${self.attachmentOptions.directory}`, { recursive: true }, (err) => __awaiter(this, void 0, void 0, function* () {
                                                if (err) {
                                                    console.log(`Error on create path: ${self.attachmentOptions.directory}`);
                                                    self.emit("error", `Error on create path: ${self.attachmentOptions.directory}`);
                                                }
                                                else {
                                                    let fileExists = fs.existsSync(`${self.attachmentOptions.directory}${att.filename}`);
                                                    if (fileExists) {
                                                        console.log(`The file ${att.filename} already exists on path: ${self.attachmentOptions.directory}`);
                                                        self.emit("error", `The file ${att.filename} already exists on path: ${self.attachmentOptions.directory}`);
                                                    }
                                                    else {
                                                        yield fs.writeFileSync(`${self.attachmentOptions.directory}${att.filename}`, att.content, (error) => {
                                                            if (error) {
                                                                console.log("Error on save attachment file: ", error);
                                                                self.emit("error", error);
                                                            }
                                                            else
                                                                console.log("The file was saved!");
                                                        });
                                                        self.emit("attachment", att, `${self.attachmentOptions.directory}${att.filename}`, seqno);
                                                    }
                                                }
                                            }));
                                        }
                                        else if (self.attachments &&
                                            self.attachmentOptions.stream) {
                                            self.emit("attachment", att, null, seqno);
                                        }
                                    }
                                }
                            }));
                        });
                        f.once("error", (error) => {
                            self.emit("error", error);
                        });
                    }, (error) => {
                        if (error) {
                            self.emit("error", error);
                        }
                    });
                }
            }
            catch (error) {
                self.emit("error", error);
            }
        });
    }
}
exports.MailListener = MailListener;
